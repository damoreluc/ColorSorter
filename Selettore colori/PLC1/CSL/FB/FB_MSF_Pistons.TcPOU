<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_MSF_Pistons" Id="{78e36ba8-cb60-4537-88b2-3ff9943f6860}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_MSF_Pistons
VAR_INPUT
	bEnable	: BOOL;  // machine enable
	slot	: INT;   // destination slot
END_VAR

VAR_IN_OUT
	st_In		:	ST_CSL_In;
	st_Params	: 	ST_CSL_Params;
	st_Out		: 	ST_CSL_RawOut;	
END_VAR

VAR_OUTPUT
	eStep	: E_Step;	//current step of the state machine
	eErrStep : E_Step;  //step where an error was raised
	nErrid	: DINT;		//error identification code
	
	bFbEnd	: BOOL;
END_VAR

VAR
	bSensor: BOOL;
	pbValve : POINTER TO BOOL;
	nStepSlot : INT;
	Error: DINT;
	iMotor	: INT := 0;         // steps done while travelling on conveyor
    
	bInitialized	: BOOL;		//FB initialization
	eNewStep : E_Step;			//request for a new step
	bEntryact	: 	BOOL;		//step entry action performed
	
	Timer_Pistons : TON();	
	fbRtMotorImpulse : R_TRIG;  // edge detection on conveyor encoder
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(* initialization *)
IF NOT bInitialized THEN    
	eNewstep 		:= 	E_Step.NoStep;    
	eStep 			:= 	E_Step.Conveyor;    
	bEntryact 		:= 	FALSE;    
	bInitialized 	:= 	TRUE; 
	bFbEnd			:=	FALSE;

	// association of the motors and the sensors to the steps
	CASE slot OF
		0:
			nStepSlot	:=	st_Params.StepNoSlot;	
		1:
			pbValve		:= 	ADR(st_Out.bValveSlot1);
			bSensor 	:= 	st_In.bSlot1;
			nStepSlot 	:= 	st_Params.StepSlot1;
		2:
			pbValve		:= 	ADR(st_Out.bValveSlot2);
			bSensor 	:= 	st_In.bSlot2;
			nStepSlot 	:= 	st_Params.StepSlot2;
		3:
			pbValve		:= 	ADR(st_Out.bValveSlot3);
			bSensor 	:= 	st_In.bSlot3;
			nStepSlot 	:= 	st_Params.StepSlot3;
			
	END_CASE


ELSE   

	(* forcing the error state *)	
	(* disabled or faulty *)
	IF  NOT bEnable THEN
		eNewstep 	:=	E_Step.NeOrError;
	END_IF;

	(* state change management *)
	IF eNewstep <> E_Step.NoStep THEN    
		eStep 		:= 	eNewstep;    
		eNewstep 	:= 	E_Step.NoStep;   
 		bEntryact 	:= 	FALSE;
	END_IF;

	
	(* input signal conditioning *)
	(*filters*)
	//Timer_Pistons (IN:= (iMotor = nStepSlot), PT := T#500MS);
	Timer_Pistons (IN:= (iMotor = nStepSlot), PT := st_Params.pistonReentryDelay);
	
	(*edges*)
	fbRtMotorImpulse(CLK:=	st_In.bMotorImpulse );

	// storing of the pieces
	CASE eStep OF

		// a new piece was placed on the conveyor belt
		E_Step.conveyor :
	
			(* body *)	
			st_Out.bMotor		:=	 TRUE;
			st_Out.bCompressor 	:=	 TRUE;
			pbValve^ 			:=	 FALSE;	
			
			(* Update steps Counter *)
			IF fbRtMotorImpulse.Q	THEN
				iMotor := iMotor + 1;
			END_IF
		
			(* transition *)	
			IF NOT bEnable THEN          
		 		eNewstep := E_Step.NeOrError;        
			ELSE 
				IF  iMotor = nStepSlot AND nStepSlot <> st_Params.StepNoSlot THEN 
					eNewstep := E_Step.piston;
				ELSIF iMotor = nStepSlot AND nStepSlot = st_Params.StepNoSlot THEN
					bFbEnd	:= TRUE;
					bInitialized := FALSE;
        		END_IF;
			END_IF
	
		// activation of the selected piston until the piece falls in its slot
		E_Step.piston :

			(* body *)
			st_Out.bMotor		:= 	FALSE;
			st_Out.bCompressor 	:= 	TRUE;
			pbValve^			:=	TRUE;
	
			(* transition *)
			IF NOT bEnable THEN          
		 		eNewstep := E_Step.NeOrError;        
			ELSE 
				IF  NOT bsensor THEN 
					eNewstep := E_Step.waiting;
       	 		END_IF;
			END_IF

		// wait the piston re-entry
		E_Step.waiting :
	
			(* body *)
			st_Out.bMotor		:=	FALSE;
			st_Out.bCompressor 	:= 	TRUE;
			pbValve^			:=	FALSE;	
			iMotor := 0;
		
			(* transition *)
			IF NOT bEnable THEN          
		 		eNewstep := E_Step.NeOrError;        
			ELSE 
				IF  Timer_Pistons.Q THEN 
					bFbEnd	:= TRUE;
					bInitialized := FALSE; 					           
       	 		END_IF;
			END_IF			
			
		ELSE
	
		// Error case
		eNewstep 	:= 	E_Step.NeOrError;
		eErrStep 	:=	E_Step.Unknown;
		nErrId 		:= 	-9; 	
		
		
	END_CASE


END_IF]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>